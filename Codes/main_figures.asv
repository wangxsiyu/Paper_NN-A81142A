masterdir = './TempData';
addpath(genpath('./'));
%%
figdir = W.mkdir('../Figures');
%% loopers
W_lp_folder = W_looper_folder(masterdir, [], [], figdir);
stjobs = W.load(fullfile(masterdir, 'setting_jobs.mat'));
W_lp_sfx = stjobs.W_lp_sfx;
%% get variables sub
sub = W.decell(W_lp_folder.looper_loadall('sub'));
sub = cellfun(@(x)x, sub);
sub = struct2table(sub);
timestep = 50;
time_at = -1000:timestep:2000;
%% set up figures
plt = setup_plot(figdir);
%% setup pipeline for the main analysis
pip = W_pipeline({'folder','sfx'}, W_lp_folder, W_lp_sfx);
pip.plotmode_on(plt);
%% figure behavior
pip.pip_addstep_folder('all', 'main_Figure_1_behavior', {sub}, {'dataset'}, [], ...
    'outputnames', 'FIG - behavior', ...
    'is_output', true, ...
    'jobname', 'fig-behavior');
% pip.pip_addstep('main_optional_Figure_1_compare_3driftrates', {plt, sub}, {}, ...
%     'jobname', 'fig-behavior-3driftrates');
% 
% %     pip.poweron;
% pip.pip_addstep('FIG_SUP_RTvsEntropy', {plt, 'SUP - RT', sub}, {'dataset'});
% pip.poweroff;
% %% figure ANOVA
% pip.pip_addstep('FIG_SUP_ANOVA', {plt, 'SUP_ANOVA', sub}, {'anova_movingwindow'});
% %% figure ANOVA + decoding
% pip.pip_addstep('main_FIGURE_1_ANOVA_decoding', {plt, sub}, {'anova_movingwindow', 'decoding_t0t1000_first20'}, [1 3 4 2]);
% pip.pip_addstep('FIG_SUP_decodeDelayDrop', {plt, 'SUP_decode', sub}, {'pca_t0t1000', 'decoding_t0t1000_first20'});
% pip.pip_addstep('main_FIGURE_2_PC20vs50', {plt, sub, time_at, 1}, {'decoding_t0t1000_first20', 'decoding_t0t1000_first50'}, [1 5 6 2 3 4]);
% pip.pip_addstep('main_FIGURE_2_PC20vs50', {plt, sub, time_at, 2}, {'decoding_t0t1000_first20', 'decoding_t0t1000_first50'}, [1 5 6 2 3 4]);
% pip.pip_addstep_sfxlooperinputs(stjobs.idxlist.id_1Danalysis, 'main_FIGURE_1_1Dvs20D', {plt, sub, time_at, 'outputname'}, ...
%     {'decoding1D_autosfx', 'decoding_t0t1000_first20'}, [1,4,5,6,2,3], 'outputnames', 'decode_1D_vs_20D_autosfx');
% pip.pip_addstep_sfxlooperinputs(stjobs.idxlist.id_1Danalysis, 'main_FIGURE_2_changeofmind', {plt, sub, 'outputname'}, ...
%     {'changeofmind1D_autosfx'}, [1,3, 4,2], 'outputnames', 'changeofmind_autosfx');
% %% trajectory
% pip.pip_addstep('FIG_SUP_avTRAJ', {plt, 'SUP - trajectory', sub}, 'x1D_t0t1000_svmp_midRT_nstd');
% pip.poweroff;
% %% Energy landscapes
% pip.pip_addstep('FIG_SUP_Grad', {plt, 'SUP - grad', sub, 450}, {'EL_t0t1000_svmp_midRT_nstd_npool1_choice'});
% 
% pip.poweroff;
% lst = W_lp_sfx.sfxlsts{stjobs.idxlist.id_EL}';
% tid = W_lp_sfx.next_sfx_ID;
% % final version
% lst = lst(strcmp(lst, 't0t1000_svmp_midRT_nstd_npool1_choice'));
% lst = unique(lst);
% W_lp_sfx.set_sfx(lst);
% pip.pip_addstep_sfxlooperinputs(tid, 'main_FIGURE_1_EL_overtime', {plt, 'outputname', sub}, ...
%     {'EL_autosfx', 'x1D_autosfx4'}, [1,2,4,5,3], 'outputnames', 'EL_overtime_autosfx');
% pip.poweroff;
% tid = W_lp_sfx.next_sfx_ID;
% W_lp_sfx.set_sfx("t0t1000", {'svm_midRT', 'svmp_midRT', 'svm_t0t1000', 'svmp_t0t1000'}, {'std', 'nstd'}, "npool1_choice", {'medianRT', '300', '350', '400', '450', '500'}, {'avGrad'});
% pip.pip_addstep_sfxlooperinputs(tid, 'main_FIGURE_2_EL_bycue', {plt, 'outputname', sub, 'variable7', 'variable8'}, ...
%     {'EL_autosfx6'}, [1,2,6,3,4,5], 'outputnames', 'EL_bycue_autosfx');
% pip.pip_addstep_sfxlooperinputs(tid, 'main_FIGURE_3_EL_ambiguouscue', {plt, 'outputname', sub, 'variable7', 'variable8'}, ...
%     {'EL_autosfx6'}, [1,2,6,3,4,5], 'outputnames', 'EL_ambcue_autosfx');
% %% figures 1-D
% lst = W_lp_sfx.sfxlsts{stjobs.idxlist.id_1Dmodel}';
% tid_1D = W_lp_sfx.next_sfx_ID;
% lst = lst(contains(lst, 'scaled') | contains(lst, 'residue'),:);
% lst = lst(~contains(lst, 'reject') & ~contains(lst, 'pyDDM'),:);
% lst = W.str2cell(lst);
% % final version
% lst = lst(contains(lst, {'t0t1000_svmp_midRT_nstd_scaledEV_npool1','t0t1000_svmp_midRT_nstd_residue_npool1', ...
%     't0t1000_svmp_midRT_nstd_scaledEVloc_npool1'}));
% lst = lst(contains(lst, {'t0t1000_svmp_midRT_nstd_scaledEV_npool1'}));
% lst = unique(lst);
% W_lp_sfx.set_sfx(lst);
% %     pip.poweron;
% pip.pip_addstep_sfxlooperinputs(tid_1D, 'FIGURE_1D_model', {plt, 'outputname', sub, 'variable5', true}, ...
%     {'model1D_autosfx'}, [1,2,6,3,4,5], 'outputnames', '1DmodelT_autosfx', 'jobname', '1D model');
% pip.poweroff;
% pip.pip_addstep_sfxlooperinputs(tid_1D, 'FIGURE_1D_model', {plt, 'outputname', sub, 'variable5', false}, ...
%     {'model1D_autosfx'}, [1,2,6,3,4,5], 'outputnames', '1Dmodel_autosfx', 'jobname', '1D model');
% pip.poweroff;
% %% 1-D evidence
% pip.pip_addstep('FIG_SUP_evidence', {plt, 'SUP - evidence', sub}, {'model1D_t0t1000_svmp_midRT_nstd_residue_npool1'});
% 
% pip.pip_addstep('FIG_SUP_alternative_dimension', {plt, 'SUP - alternative dimension', sub, 400}, ...
%     {'model1D_t0t1000_svmp_midRT_nstd_scaledEV_npool1', 'model1D_t0t1000_mean_midRT_nstd_scaledEV_npool1'});
% pip.poweroff;
% %% 1-D RT
% pip.pip_addstep_sfxlooperinputs(tid_1D, 'FIG_1Dmodel_RT', {plt, 'outputname', sub, 'reject'}, ...
%     {'model1D_autosfx'}, [1,2,6,3,4,5], 'outputnames', '1DRT_reject_autosfx', 'jobname', '1D model RT reject');
% pip.pip_addstep_sfxlooperinputs(tid_1D, 'FIG_1Dmodel_RT', {plt, 'outputname', sub, 'accept'}, ...
%     {'model1D_autosfx'}, [1,2,6,3,4,5], 'outputnames', '1DRT_accept_autosfx', 'jobname', '1D model RT accept');
% pip.poweroff;
% %% optional figure rejectonlyx
% if version == "all_CUEON_win50_step50"
%     pip.pip_addstep('FIGURE_rejectonly', {plt, 'outputname', sub}, ...
%         {'model1D_t0t1000_svm_midRT_nstd_scaledEVrejectonly_npool1', 'model1D_t0t1000_svm_midRT_nstd_scaledEVpyDDM_npool1', 'model1D_t0t1000_svm_midRT_nstd_scaledEVpyDDMCB_npool1'}, ...
%         'outputnames', '1Dmodel_rejectonly', 'jobname', '1D model reject only');
% end
% %% control
% pip.pip_addstep('FIGURE_1D_control', {plt, 'outputname', sub}, ...
%     {'model1D_t0t1000_svm_midRT_nstd_control_npool1'}, ...
%     'outputnames', '1Dmodel_control', 'jobname', '1D model control');
% %     pip.poweron;
% %% parameter recovery
% W_lp_sfx.next_sfx_ID;
% W_lp_sfx.set_sfx('t0t1000', {'svmp_midRT'}, {'nstd'}, 'scaledEV', {'npool1'});
% pip.pip_addstep_sfxlooperinputs(W_lp_sfx.sfxid, 'FIGURE_param_recover', {plt, 'outputname'}, {'model1D_autosfx', 'model1Dsimu_autosfx'}, ...
%     'outputnames', 'parameter_recovery_autosfx');
% %% posterior predictive checks
% W_lp_sfx.next_sfx_ID;
% pip.poweron;
% W_lp_sfx.set_sfx('t0t1000', {'svmp_midRT'}, {'nstd'}, {'npool3'}, 'choice', {'medianRT'}, {'avGrad'});
% pip.pip_addstep_sfxlooperinputs(W_lp_sfx.sfxid, 'main_FIGURE_2_EL_bycue', {plt, 'outputname', sub, 'variable7', 'variable8'}, ...
%     {'ELsimu_autosfx6'}, [1,2,6,3,4,5], 'outputnames', 'ELsimu_bycue_autosfx');
% pip.poweroff;
% %% symmetry 3D
% W_lp_sfx.next_sfx_ID;
% %     W_lp_sfx.set_sfx('t0t1000', {'svmp_t0t1000_nstd', 'svmp_midRT_nstd', 'svm_t0t1000_nstd', 'svm_midRT_nstd', 'r_a_w'}, ...
% %         {'attractor'}, {'npool1', 'npool3'});
% W_lp_sfx.set_sfx('t0t1000', {'svmp_t0t1000_nstd'}, ...
%     {'attractor'}, {'npool3'});
% pip.pip_addstep_sfxlooperinputs(W_lp_sfx.sfxid, 'main_FIGURE_1_symmetry', {plt, 'outputname', sub}, ...
%     {'model3D_autosfx'}, 'outputnames', 'curl3D_autosfx');
% pip.poweroff;
% %     pip.poweron;
% pip.pip_addstep_sfxlooperinputs(stjobs.idxlist.id_3Dmodel, 'main_FIGURE_2_model3D', {plt, 'outputname', sub}, ...
%     {'model3D_autosfx'}, 'outputnames', 'model3D_autosfx');
% W_lp_sfx.next_sfx_ID;
% %     W_lp_sfx.set_sfx('t0t1000', {'svmp_t0t1000_nstd', 'svmp_midRT_nstd', 'svm_t0t1000_nstd', 'svm_midRT_nstd', 'r_a_w'}, ...
% %         {'attractor'}, {'npool1', 'npool3'});
% W_lp_sfx.set_sfx('t0t1000', {'svmp_t0t1000_nstd'}, ...
%     {'attractor'}, {'npool3'});
% %     pip.poweron;
% pip.pip_addstep_sfxlooperinputs(W_lp_sfx.sfxid, 'main_FIGURE_3_model3D_x0', {plt, 'outputname', sub}, ...
%     {'model3D_autosfx', 'x1D_t0t1000_svmp_t0t1000_nstd'}, 'outputnames', 'model3Dx0_autosfx');
% pip.poweroff;
% %% pos-neg
% pip.pip_addstep('main_FIGURE_1_loadings', {plt, 'outputname', sub}, {'meanFR_posneg', 'loadings_pos_neg'}, ...
%     'outputnames', 'POSNEG - loadings');
% pip.poweroff;
% %%
% pip.pip_addstep('main_FIGURE_2_1D_model', {plt, 'outputname', sub}, {'model1D_posneg'}, ...
%     'outputnames', 'POSNEG - model');
%% generate jobs
jobs = W_job_looper;
jobs.add_jobs_from_pip(pip);
%% analysis for all versions
jobs.overwrite_off;
jobs.parfor_off;
jobs.run();
